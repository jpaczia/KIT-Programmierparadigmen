\section{Klausuren}
\subsection{Haskell}
\begin{table}[h]
	\centering
	\label{my-label}
	\begin{tabular}{ll}
		Bäume, mapTree, reduceTree / foldTree, treeSum, treeConcat, treeToList
		& WS 11 / 12  \\
		
		Hirsch-Index, Bäume, allTrees, trees\_4\_13
		& SS 12 \\
		
		Lauflängenenkodierung, splitWhen, group, encode 
		& WS 12 / 13 (Nr. 1)\\
		
		Java-Bytecode Erzeugung 
		& WS 12 / 13 (Nr. 8)\\
		
		Laziness, Streams, pythagoreisches Tripel 
		& SS 13 (Nr. 1)\\
		
		splits, alle möglichen Teillisten 
		& SS 13 (Nr. 4)\\
		
		Hamming-Zahlen 
		& WS 13 / 14 (Nr. 1)\\
		
		Kombinatoren, unendliche Liste, Eulerverfahren, iterate, zipWith 
		& WS 13 / 14 (Nr. 2)\\
		
		last (Listen-Element), inits 
		& SS 14 (Nr. 1)\\
		
		lexikalische Analyse, Maybe, Automat, Zahlensystem 
		& SS 14 (Nr. 2)\\
		
		Newton-Iteration
		& WS 14 / 15 (Nr. 1) \\
		
		binäre Bäume, deleteMin, merge Trees
		& WS 14 / 15 (Nr. 2) \\
		
		splitWords (Word, NonWord), joinWords, capitalize
		& SS 15 (Nr. 1) \\
	\end{tabular}
\end{table}
~\\

\subsection{Prolog}
\begin{table}[h]
	\centering
	\label{my-label}
	\begin{tabular}{ll}
		Nichtdeterminismus, Wechselgeld, removeMoney, changeMoney
		& WS 11 / 12  \\
				
		Wolf, Ziege, Kohl
		& SS 12 \\
		
		Labyrinth
		& WS 12 / 13 \\
		
		splits, alle möglichen Teillisten (Nr. 4)
		& SS 13 \\
		
		Differenzlisten (Nr. 5)
		& SS 13 \\
		
		reguläre Ausdrücke (Nr. 5)
		& WS 13 / 14 \\
		
		Java-Bytecodeerzeugung (Nr. 5)
		& SS 14 \\
		
		del, delete, freie Variablen in Lambda-Ausdruck
		& WS 14 / 15 (Nr. 4) \\
		
		Haus vom Nikolaus, Eulerpfade, swap (Kanten umdrehen)
		& SS 15 (Nr. 4) \\
	\end{tabular}
\end{table}
~\\

\subsection{$\lambda$-Kalkül}
\begin{table}[h]
\centering
\label{my-label}
\begin{tabular}{ll}
	Fixpunktkombinator, $\beta$-Reduktion
	& WS 11 / 12  \\
	
	Kombinatoren, $\beta$-Reduktion, S K I
	& SS 12 \\
	
	Church-Paare, fst, snd, map, allgemeinster Typ
	& WS 12 / 13 \\
	
	Church-Paare, next, pred (Nr. 2)
	& SS 13 \\
	
	Church-Zahlen, isZero, pred, add (Nr. 3)
	& WS 13 / 14 \\
	
	Scott-Zahlen, isZero, pred, sub (Nr. 3)
	& SS 14 \\
	
	freie Variablen, Redex, call-by-name, Normalform, $\alpha$- \& $\eta$-Äquivalenz 
	& WS 14 / 15 (Nr. 3) \\
	
	S K I, Normalform
	& SS 15 (Nr. 2) \\
\end{tabular}
\end{table}
~\\

\subsection{Typinferenz}
\begin{table}[h]
\centering
\label{my-label}
\begin{tabular}{ll}
	S K I, Let-Polymorphismus
	& WS 11 / 12  \\
	
	Unifikation, Prolog-Notation
	& SS 12\\
	
	allgemeinster Typ, Typschema, let-Polymorphismus (Nr. 3)
	& SS 13 \\
	
	let-Polymorphismus, $\lambda$-gebunde Variable $\rightarrow$ nicht polymorph (Nr. 4)
	& WS 13 / 14 \\
	
	Scott-Zahlen, allgemeinster Typ, mgu (Nr. 4)
	& SS 14 \\
	
	mgu, $\tau_{just}$, let-Polymorphismus
	& WS 14 / 15 (Nr. 5) \\
	
	mgu, Herleitungsbaum, let-Polymorphismus, $\lambda$-gebunde Variable $\rightarrow$ nicht polymorph
	& SS 15 (Nr. 3) \\
\end{tabular}
\end{table}
~\\

\subsection{Parallel Basics}
\begin{table}[h]
	\centering
	\label{my-label}
	\begin{tabular}{ll}		
		Flynn’s Taxonomie 
		& WS 13 / 14 (Nr. 9), SS 14 (Nr. 6)\\		
		
		\multlineTable{Vorteile, Risiken, Thread-Scheduling, Sperren, Race-Bedingung,\\ Deadlock, blocking vs. non-blocking, synchron-Send}
		& WS 14 / 15 (Nr. 6) \\			
		
		Beschleunigung berechnen, Amdahls Law
		& WS 14 / 15 (Nr. 6) \\		
	\end{tabular}
\end{table}
~\\

\subsection{C}
\begin{table}[h]
\centering
\label{my-label}
\begin{tabular}{ll}
	Zeiger-Arithmetik, Arrays
	& WS 11 / 12  \\
	
	Zeiger-Arithmetik, Arrays
	& SS 12 \\
	
	Precedence-Rule
	& WS 12 / 13 \\
	
	Precedence-Rule
	& \multlineTable{SS 13 (Nr. 6)\\ WS 13 / 14 (Nr. 6)\\ SS 14 (Nr. 9) } \\	
\end{tabular}
\end{table}
~\\

\subsection{MPI}
\begin{table}[h]
	\centering
	\label{my-label}
	\begin{tabular}{ll}
		kollektive Operationen, Durchschnitt
		& WS 11 / 12  \open\\
		
		Matrix-Multiplikation
		& SS 12 \open, SS 14 (Nr. 8) \\
		
		Broadcast-Implementierung
		& WS 12 / 13 \open \\
		
		Reduce, Reduce-Implementierung 
		& SS 13 (Nr. 7)\\
		
		Allgather \& Alltoall 
		& WS 13 / 14 (Nr. 7) \\	
		
		Scatterv / Gatherv
		& SS 14 (Nr. 8) \\		
		
		Send, Recv, Finalize, Parameter-Beschreibungen
		& WS 14 / 15 (Nr. 9) \\	
		
		Gather-Implementierung
		& SS 15 (Nr. 5) \\
	\end{tabular}
\end{table}
~\\

\subsection{Compiler}
\begin{table}[h]
	\centering
	\label{my-label}
	\begin{tabular}{ll}
		Syntaktische Analyse, abstrakte Syntax, rekursiver Abstiegsparser
		& WS 11 / 12 \open \\		
		
		Syntaktische Analyse, abstrakte Syntax, rekursiver Abstiegsparser
		& SS 12 \open \\
		
		Haskell, Java-Bytecode Erzeugung
		& WS 12 / 13 \open \\
		
		First-\& Follow-Mengen 
		& \multlineTable{WS 12 / 13 \open\\ SS 14 (Nr. 10)} \\	
		
		Linksfaktorisierung, Haskell-Datentyp, Abstiegsparser 
		& SS 13 (Nr. 9) \\
		
		Abstiegsparser 
		& WS 13 / 14 (Nr. 10) \\	
		
		Linksfaktorisierung, SLL(1), abstrakte Syntax, Klassenherarchie, Abstiegsparser
		& WS 14 / 15 (Nr. 10) \\	
		
		Linksfaktorisierung, abstrakte Syntax, Abstiegsparser, abstrakter Syntaxbaum
		& SS 15 (Nr. 2) \\
	\end{tabular}
\end{table}
~\\